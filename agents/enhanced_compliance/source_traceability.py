"""
PropelAI Source Traceability Module

Provides complete audit trail for all extracted and generated content.
Every requirement can be traced back to its exact source location.

Key features:
1. Character offset tracking (exact position in source document)
2. Page number mapping
3. Confidence scoring
4. Verification status tracking
5. Audit trail for all changes

Usage:
    from agents.enhanced_compliance.source_traceability import SourceTracker, SourceTrace

    tracker = SourceTracker()

    # When extracting a requirement
    trace = tracker.create_trace(
        content="The contractor shall provide...",
        source_type=SourceType.RFP_EXTRACTION,
        document_name="solicitation.pdf",
        page_number=45,
        char_start=12450,
        char_end=12580,
        confidence=0.95
    )

    # Later, to verify
    tracker.mark_verified(trace.id, verified_by="john@company.com")
"""

import hashlib
import json
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid


class SourceType(Enum):
    """Type of content source"""
    RFP_EXTRACTION = "rfp_extraction"       # Extracted from RFP document
    CONTENT_LIBRARY = "content_library"     # From reusable content library
    AI_GENERATED = "ai_generated"           # Generated by AI
    HUMAN_WRITTEN = "human_written"         # Written by human
    TEMPLATE = "template"                   # From template
    PAST_PERFORMANCE = "past_performance"   # From past performance database
    HYBRID = "hybrid"                       # Combination of sources


class VerificationStatus(Enum):
    """Content verification status"""
    UNVERIFIED = "unverified"
    VERIFIED = "verified"
    REJECTED = "rejected"
    NEEDS_REVIEW = "needs_review"


@dataclass
class AuditEntry:
    """Single entry in the audit trail"""
    timestamp: str
    action: str                 # "created", "modified", "verified", "rejected"
    user: Optional[str]
    details: str
    previous_value: Optional[str] = None
    new_value: Optional[str] = None


@dataclass
class SourceTrace:
    """
    Complete traceability record for a piece of content.

    This enables:
    - "Where did this come from?" - document_name, page_number, char_start/end
    - "How confident is the extraction?" - confidence_score
    - "Has this been verified?" - verification_status
    - "What changed?" - audit_trail
    """
    # Unique identifier
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])

    # Content identification
    content_hash: str = ""              # Hash of the content for deduplication
    content_preview: str = ""           # First 100 chars for display

    # Source information
    source_type: SourceType = SourceType.RFP_EXTRACTION
    document_name: str = ""
    page_number: int = 0
    char_start: int = 0                 # Start offset in source document
    char_end: int = 0                   # End offset in source document

    # For content library sources
    library_item_id: Optional[str] = None
    library_item_version: Optional[str] = None

    # Confidence and quality
    confidence_score: float = 1.0       # 0.0 - 1.0
    extraction_method: str = ""         # "regex", "nlp", "ai", "manual"

    # Verification
    verification_status: VerificationStatus = VerificationStatus.UNVERIFIED
    verified_by: Optional[str] = None
    verified_at: Optional[str] = None
    verification_notes: Optional[str] = None

    # Audit trail
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    audit_trail: List[AuditEntry] = field(default_factory=list)

    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        if not self.content_hash and self.content_preview:
            self.content_hash = hashlib.md5(
                self.content_preview.encode()
            ).hexdigest()[:16]

        # Add creation entry to audit trail
        if not self.audit_trail:
            self.audit_trail.append(AuditEntry(
                timestamp=self.created_at,
                action="created",
                user=None,
                details=f"Source trace created from {self.document_name}"
            ))


@dataclass
class TraceableRequirement:
    """
    A requirement with full source traceability.

    Extends StructuredRequirement with traceability.
    """
    requirement_id: str
    full_text: str
    trace: SourceTrace
    # Reference to parent requirement if this was derived
    derived_from: Optional[str] = None


class SourceTracker:
    """
    Manages source traceability for all content.

    Provides:
    - Create traces for extracted content
    - Link traces to requirements
    - Track verification status
    - Export audit trails
    """

    def __init__(self):
        self.traces: Dict[str, SourceTrace] = {}
        self.requirement_traces: Dict[str, str] = {}  # requirement_id -> trace_id

    def create_trace(
        self,
        content: str,
        source_type: SourceType,
        document_name: str = "",
        page_number: int = 0,
        char_start: int = 0,
        char_end: int = 0,
        confidence: float = 1.0,
        extraction_method: str = "regex",
        metadata: Optional[Dict[str, Any]] = None
    ) -> SourceTrace:
        """
        Create a new source trace.

        Args:
            content: The extracted/generated content
            source_type: Type of source
            document_name: Source document filename
            page_number: Page in source document
            char_start: Start character offset
            char_end: End character offset
            confidence: Extraction confidence (0-1)
            extraction_method: How was this extracted
            metadata: Additional metadata

        Returns:
            SourceTrace object
        """
        trace = SourceTrace(
            content_preview=content[:100] if content else "",
            source_type=source_type,
            document_name=document_name,
            page_number=page_number,
            char_start=char_start,
            char_end=char_end,
            confidence_score=confidence,
            extraction_method=extraction_method,
            metadata=metadata or {}
        )

        self.traces[trace.id] = trace
        return trace

    def link_requirement(
        self,
        requirement_id: str,
        trace_id: str
    ) -> bool:
        """Link a requirement to its source trace"""
        if trace_id not in self.traces:
            return False
        self.requirement_traces[requirement_id] = trace_id
        return True

    def get_trace(self, trace_id: str) -> Optional[SourceTrace]:
        """Get a trace by ID"""
        return self.traces.get(trace_id)

    def get_requirement_trace(self, requirement_id: str) -> Optional[SourceTrace]:
        """Get the trace for a requirement"""
        trace_id = self.requirement_traces.get(requirement_id)
        if trace_id:
            return self.traces.get(trace_id)
        return None

    def mark_verified(
        self,
        trace_id: str,
        verified_by: str,
        notes: Optional[str] = None
    ) -> bool:
        """Mark a trace as verified"""
        trace = self.traces.get(trace_id)
        if not trace:
            return False

        trace.verification_status = VerificationStatus.VERIFIED
        trace.verified_by = verified_by
        trace.verified_at = datetime.now().isoformat()
        trace.verification_notes = notes

        trace.audit_trail.append(AuditEntry(
            timestamp=trace.verified_at,
            action="verified",
            user=verified_by,
            details=notes or "Marked as verified"
        ))

        return True

    def mark_rejected(
        self,
        trace_id: str,
        rejected_by: str,
        reason: str
    ) -> bool:
        """Mark a trace as rejected (incorrect extraction)"""
        trace = self.traces.get(trace_id)
        if not trace:
            return False

        trace.verification_status = VerificationStatus.REJECTED
        trace.verified_by = rejected_by
        trace.verified_at = datetime.now().isoformat()
        trace.verification_notes = reason

        trace.audit_trail.append(AuditEntry(
            timestamp=trace.verified_at,
            action="rejected",
            user=rejected_by,
            details=reason
        ))

        return True

    def add_audit_entry(
        self,
        trace_id: str,
        action: str,
        user: Optional[str],
        details: str,
        previous_value: Optional[str] = None,
        new_value: Optional[str] = None
    ) -> bool:
        """Add an audit entry to a trace"""
        trace = self.traces.get(trace_id)
        if not trace:
            return False

        trace.audit_trail.append(AuditEntry(
            timestamp=datetime.now().isoformat(),
            action=action,
            user=user,
            details=details,
            previous_value=previous_value,
            new_value=new_value
        ))

        return True

    def get_unverified_traces(self) -> List[SourceTrace]:
        """Get all unverified traces"""
        return [
            t for t in self.traces.values()
            if t.verification_status == VerificationStatus.UNVERIFIED
        ]

    def get_low_confidence_traces(self, threshold: float = 0.8) -> List[SourceTrace]:
        """Get traces below confidence threshold"""
        return [
            t for t in self.traces.values()
            if t.confidence_score < threshold
        ]

    def calculate_verification_rate(self) -> float:
        """Calculate percentage of verified traces"""
        if not self.traces:
            return 0.0
        verified = sum(
            1 for t in self.traces.values()
            if t.verification_status == VerificationStatus.VERIFIED
        )
        return verified / len(self.traces)

    def export_audit_trail(self, trace_id: str) -> Dict[str, Any]:
        """Export full audit trail for a trace"""
        trace = self.traces.get(trace_id)
        if not trace:
            return {}

        return {
            'trace_id': trace.id,
            'content_preview': trace.content_preview,
            'source': {
                'type': trace.source_type.value,
                'document': trace.document_name,
                'page': trace.page_number,
                'char_range': [trace.char_start, trace.char_end]
            },
            'confidence': trace.confidence_score,
            'verification': {
                'status': trace.verification_status.value,
                'verified_by': trace.verified_by,
                'verified_at': trace.verified_at,
                'notes': trace.verification_notes
            },
            'audit_trail': [
                {
                    'timestamp': entry.timestamp,
                    'action': entry.action,
                    'user': entry.user,
                    'details': entry.details
                }
                for entry in trace.audit_trail
            ]
        }

    def export_all_traces(self) -> List[Dict[str, Any]]:
        """Export all traces as JSON-serializable dicts"""
        return [self.export_audit_trail(tid) for tid in self.traces]


class SourceTrackerWithOffsets:
    """
    Extended tracker that maintains character offsets during document processing.

    This enables "View Source" functionality where clicking a requirement
    shows the exact location in the original document.
    """

    def __init__(self):
        self.tracker = SourceTracker()
        self.document_offsets: Dict[str, List[Tuple[int, int, int]]] = {}
        # filename -> [(char_start, page_number, page_start_in_combined)]

    def register_document(
        self,
        filename: str,
        pages: List[str],
        combined_text_start: int = 0
    ):
        """
        Register a document and its page boundaries.

        Args:
            filename: Document filename
            pages: List of page text content
            combined_text_start: Offset where this doc starts in combined text
        """
        offsets = []
        current_offset = combined_text_start

        for page_num, page_text in enumerate(pages, 1):
            offsets.append((current_offset, page_num, combined_text_start))
            current_offset += len(page_text) + 2  # +2 for newlines

        self.document_offsets[filename] = offsets

    def offset_to_location(
        self,
        char_offset: int,
        filename: Optional[str] = None
    ) -> Tuple[str, int, int]:
        """
        Convert character offset to (document, page, offset_in_page).

        Args:
            char_offset: Character offset in combined text
            filename: Optional filename hint

        Returns:
            (document_name, page_number, offset_within_page)
        """
        # If filename provided, search that document
        if filename and filename in self.document_offsets:
            offsets = self.document_offsets[filename]
            for i, (start, page_num, doc_start) in enumerate(offsets):
                if i + 1 < len(offsets):
                    if start <= char_offset < offsets[i + 1][0]:
                        return filename, page_num, char_offset - start
                else:
                    if char_offset >= start:
                        return filename, page_num, char_offset - start

        # Search all documents
        for fname, offsets in self.document_offsets.items():
            for i, (start, page_num, doc_start) in enumerate(offsets):
                if i + 1 < len(offsets):
                    if start <= char_offset < offsets[i + 1][0]:
                        return fname, page_num, char_offset - start
                else:
                    if char_offset >= start:
                        return fname, page_num, char_offset - start

        return "unknown", 1, char_offset

    def create_trace_from_offset(
        self,
        content: str,
        char_start: int,
        char_end: int,
        confidence: float = 1.0,
        extraction_method: str = "regex"
    ) -> SourceTrace:
        """
        Create a trace with automatic location resolution.

        Args:
            content: Extracted content
            char_start: Start offset in combined text
            char_end: End offset in combined text
            confidence: Extraction confidence
            extraction_method: How content was extracted

        Returns:
            SourceTrace with resolved location
        """
        doc_name, page_num, _ = self.offset_to_location(char_start)

        return self.tracker.create_trace(
            content=content,
            source_type=SourceType.RFP_EXTRACTION,
            document_name=doc_name,
            page_number=page_num,
            char_start=char_start,
            char_end=char_end,
            confidence=confidence,
            extraction_method=extraction_method
        )

    def get_source_text(
        self,
        combined_text: str,
        trace: SourceTrace,
        context_chars: int = 200
    ) -> Dict[str, str]:
        """
        Get the source text for a trace with context.

        Args:
            combined_text: Full combined document text
            trace: Source trace
            context_chars: Characters of context to include

        Returns:
            Dict with 'before', 'match', 'after' text
        """
        start = max(0, trace.char_start - context_chars)
        end = min(len(combined_text), trace.char_end + context_chars)

        return {
            'before': combined_text[start:trace.char_start],
            'match': combined_text[trace.char_start:trace.char_end],
            'after': combined_text[trace.char_end:end],
            'document': trace.document_name,
            'page': trace.page_number
        }


# Convenience functions
def create_trace(
    content: str,
    document_name: str,
    page_number: int,
    char_start: int = 0,
    char_end: int = 0,
    confidence: float = 1.0
) -> SourceTrace:
    """
    Quick trace creation for extracted content.

    Usage:
        trace = create_trace(
            content="The contractor shall...",
            document_name="solicitation.pdf",
            page_number=45,
            char_start=12450,
            char_end=12580
        )
    """
    tracker = SourceTracker()
    return tracker.create_trace(
        content=content,
        source_type=SourceType.RFP_EXTRACTION,
        document_name=document_name,
        page_number=page_number,
        char_start=char_start,
        char_end=char_end,
        confidence=confidence
    )
