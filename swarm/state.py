"""
PropelAI v6.0 ProposalState Schema
The persistent state of the proposal engagement, managed by LangGraph checkpoints.
"""

from typing import TypedDict, List, Dict, Optional, Any, Annotated
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import operator
import json


class ProposalPhase(str, Enum):
    """Phases of the proposal lifecycle."""
    SHRED = "shred"
    STRATEGY = "strategy"
    DRAFTING = "drafting"
    REVIEW = "review"
    FINALIZE = "finalize"
    COMPLETE = "complete"


class ComplianceStatus(str, Enum):
    """Compliance status for requirements."""
    COMPLIANT = "compliant"
    PARTIAL = "partial"
    NON_COMPLIANT = "non_compliant"
    PENDING = "pending"
    NOT_APPLICABLE = "not_applicable"


class ScoreColor(str, Enum):
    """DoD Source Selection scoring colors."""
    BLUE = "blue"        # Outstanding - exceeds with significant strengths
    GREEN = "green"      # Good - meets requirements
    YELLOW = "yellow"    # Marginal - meets but with risks
    RED = "red"          # Unacceptable - fails to meet


class RequirementType(str, Enum):
    """Types of requirements from the Iron Triangle."""
    TECHNICAL = "technical"           # Section C/PWS/SOW
    MANAGEMENT = "management"         # Management approach
    PAST_PERFORMANCE = "past_performance"
    COST_PRICE = "cost_price"
    SMALL_BUSINESS = "small_business"
    ORAL_PRESENTATION = "oral_presentation"
    SAMPLE_TASK = "sample_task"


@dataclass
class Requirement:
    """
    Represents a single atomic requirement from the RFP.
    Extracted by the Compliance Agent with full traceability.
    """
    id: str
    text: str
    source_doc: str
    page_num: int
    section_ref: str  # e.g., "L.4.2.1", "C.3.1"
    requirement_type: RequirementType = RequirementType.TECHNICAL
    compliance_status: ComplianceStatus = ComplianceStatus.PENDING

    # Traceability
    bbox_coordinates: Optional[Dict[str, float]] = None  # {x, y, width, height}
    citation_link: Optional[str] = None

    # Iron Triangle mapping
    instruction_ref: Optional[str] = None   # Section L reference
    evaluation_ref: Optional[str] = None    # Section M reference

    # Binding level
    binding_keyword: Optional[str] = None   # shall, must, will, should, may
    is_mandatory: bool = True

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "text": self.text,
            "source_doc": self.source_doc,
            "page_num": self.page_num,
            "section_ref": self.section_ref,
            "requirement_type": self.requirement_type.value,
            "compliance_status": self.compliance_status.value,
            "bbox_coordinates": self.bbox_coordinates,
            "citation_link": self.citation_link,
            "instruction_ref": self.instruction_ref,
            "evaluation_ref": self.evaluation_ref,
            "binding_keyword": self.binding_keyword,
            "is_mandatory": self.is_mandatory,
        }


@dataclass
class WinTheme:
    """
    Represents a strategic angle for a specific section.
    Generated by the Strategy Agent using Black Hat logic.
    """
    id: str
    section_id: str
    theme: str
    competitor_ghosting: str  # Subtle competitive positioning
    proof_points: List[str] = field(default_factory=list)

    # Evaluation mapping
    evaluation_factor: Optional[str] = None
    evaluation_weight: Optional[float] = None

    # Confidence
    confidence: float = 0.8

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "section_id": self.section_id,
            "theme": self.theme,
            "competitor_ghosting": self.competitor_ghosting,
            "proof_points": self.proof_points,
            "evaluation_factor": self.evaluation_factor,
            "evaluation_weight": self.evaluation_weight,
            "confidence": self.confidence,
        }


@dataclass
class Evidence:
    """
    A piece of verified evidence from the Research Agent.
    Used by Drafting Agent for citation-backed claims.
    """
    id: str
    source_type: str  # "library", "past_performance", "resume", "external"
    source_id: str
    source_name: str
    page_number: Optional[int] = None
    snippet_text: str = ""
    relevance_score: float = 0.0

    # Citation format
    citation_text: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "source_type": self.source_type,
            "source_id": self.source_id,
            "source_name": self.source_name,
            "page_number": self.page_number,
            "snippet_text": self.snippet_text,
            "relevance_score": self.relevance_score,
            "citation_text": self.citation_text,
        }


@dataclass
class DraftSection:
    """
    Represents a section of the proposal text.
    Managed through the drafting and review cycle.
    """
    section_id: str
    title: str
    content: str
    version: int = 1

    # Quality metrics
    quality_score: float = 0.0  # Red Team score (0.0 to 1.0)
    score_color: ScoreColor = ScoreColor.YELLOW

    # Citations and evidence
    citations: List[str] = field(default_factory=list)
    evidence_ids: List[str] = field(default_factory=list)

    # Feedback from Red Team
    feedback_log: List[str] = field(default_factory=list)

    # Compliance mapping
    requirement_ids: List[str] = field(default_factory=list)
    win_theme_id: Optional[str] = None

    # Page allocation
    page_limit: Optional[int] = None
    current_pages: float = 0.0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "section_id": self.section_id,
            "title": self.title,
            "content": self.content,
            "version": self.version,
            "quality_score": self.quality_score,
            "score_color": self.score_color.value,
            "citations": self.citations,
            "evidence_ids": self.evidence_ids,
            "feedback_log": self.feedback_log,
            "requirement_ids": self.requirement_ids,
            "win_theme_id": self.win_theme_id,
            "page_limit": self.page_limit,
            "current_pages": self.current_pages,
        }


@dataclass
class AgentAction:
    """
    Record of an agent action for the trace log.
    Enables RLHF and debugging.
    """
    timestamp: datetime
    agent_name: str
    action_type: str  # "thought", "action", "observation", "output"
    content: str
    tool_calls: Optional[List[Dict[str, Any]]] = None
    tool_outputs: Optional[List[Dict[str, Any]]] = None
    tokens_input: int = 0
    tokens_output: int = 0
    latency_ms: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp.isoformat(),
            "agent_name": self.agent_name,
            "action_type": self.action_type,
            "content": self.content,
            "tool_calls": self.tool_calls,
            "tool_outputs": self.tool_outputs,
            "tokens_input": self.tokens_input,
            "tokens_output": self.tokens_output,
            "latency_ms": self.latency_ms,
        }


def merge_dict(a: Dict, b: Dict) -> Dict:
    """Merge two dictionaries, with b overwriting a."""
    return {**a, **b}


class ProposalState(TypedDict, total=False):
    """
    The persistent state of the proposal engagement.
    Managed by LangGraph checkpoints in PostgreSQL.

    This state flows through all agents and persists across
    server restarts, enabling long-running autonomous workflows.
    """

    # =========================================================================
    # Meta Information (Immutable identifiers)
    # =========================================================================
    proposal_id: str
    tenant_id: str
    rfp_id: str

    # Current phase in the proposal lifecycle
    current_phase: str  # ProposalPhase value

    # =========================================================================
    # The Iron Triangle Graph
    # Maps relationships: Requirement (C) <-> Instruction (L) <-> Criteria (M)
    # Serialized as adjacency list for LangGraph compatibility
    # =========================================================================
    requirements_graph: Dict[str, List[str]]  # Serialized NetworkX graph

    # =========================================================================
    # Core Artifacts (Annotated for parallel agent updates)
    # operator.add ensures agents append to lists rather than overwriting
    # =========================================================================
    requirements: Annotated[List[Dict], operator.add]
    win_themes: Annotated[List[Dict], operator.add]
    evidence_pool: Annotated[List[Dict], operator.add]

    # =========================================================================
    # Draft Content
    # Using dict merge allows parallel agents to update different sections
    # =========================================================================
    draft_sections: Dict[str, Dict]  # section_id -> DraftSection dict

    # =========================================================================
    # Context Data (The "Long Context" Memory)
    # =========================================================================
    rfp_full_text: str  # Full solicitation text (Gemini 2M context)
    rfp_sections: Dict[str, str]  # section_id -> section text

    # Section L (Instructions)
    section_l_text: str
    section_l_requirements: List[Dict]

    # Section M (Evaluation)
    section_m_text: str
    evaluation_factors: List[Dict]

    # Section C/PWS/SOW (Technical)
    section_c_text: str
    technical_requirements: List[Dict]

    # =========================================================================
    # Agent Coordination
    # =========================================================================
    next_step: str  # Next node in the graph
    current_agent: str  # Currently executing agent
    supervisor_scratchpad: List[str]  # Supervisor's reasoning log

    # Retry and error handling
    retry_count: int
    max_retries: int
    last_error: Optional[str]

    # =========================================================================
    # Governance & Traceability
    # =========================================================================
    agent_trace_log: Annotated[List[Dict], operator.add]  # Immutable audit trail
    human_feedback: Annotated[List[Dict], operator.add]   # User corrections for RLHF

    # Quality metrics
    overall_score: float
    section_scores: Dict[str, float]

    # Timestamps
    created_at: str
    updated_at: str
    completed_at: Optional[str]


def create_initial_state(
    proposal_id: str,
    tenant_id: str,
    rfp_id: str,
    rfp_full_text: str = "",
) -> ProposalState:
    """Create an initial ProposalState for a new proposal."""
    now = datetime.utcnow().isoformat()

    return ProposalState(
        # Meta
        proposal_id=proposal_id,
        tenant_id=tenant_id,
        rfp_id=rfp_id,
        current_phase=ProposalPhase.SHRED.value,

        # Graph
        requirements_graph={},

        # Artifacts
        requirements=[],
        win_themes=[],
        evidence_pool=[],

        # Drafts
        draft_sections={},

        # Context
        rfp_full_text=rfp_full_text,
        rfp_sections={},
        section_l_text="",
        section_l_requirements=[],
        section_m_text="",
        evaluation_factors=[],
        section_c_text="",
        technical_requirements=[],

        # Coordination
        next_step="compliance",
        current_agent="",
        supervisor_scratchpad=[],
        retry_count=0,
        max_retries=3,
        last_error=None,

        # Governance
        agent_trace_log=[],
        human_feedback=[],
        overall_score=0.0,
        section_scores={},

        # Timestamps
        created_at=now,
        updated_at=now,
        completed_at=None,
    )
